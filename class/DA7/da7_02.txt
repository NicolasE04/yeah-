// main.c
#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <math.h>
#include <stdlib.h>    
#include <inttypes.h>

#include "i2c.h"       
#include "bmi160.h"    


#define SSD1306_ADDRESS       0x3C
#define SSD1306_COMMAND       0x00
#define SSD1306_DATA_CONTINUE 0x40
#define FONT_SIZE 5

static void oledSendStart(uint8_t addr_byte) {
	i2c_start();
	i2c_write((addr_byte << 1) | 0 /* write */);
}
static void oledSendStop(void) {
	i2c_stop();
}
static void oledSendCommand(uint8_t cmd) {
	oledSendStart(SSD1306_ADDRESS);
	i2c_write(SSD1306_COMMAND);
	i2c_write(cmd);
	oledSendStop();
}
static void oledSendData(uint8_t data) {
	oledSendStart(SSD1306_ADDRESS);
	i2c_write(SSD1306_DATA_CONTINUE);
	i2c_write(data);
	oledSendStop();
}


const unsigned char OledFontTable[][FONT_SIZE]={
	
	0x00, 0x00, 0x00, 0x00, 0x00,   // space
	0x00, 0x00, 0x2f, 0x00, 0x00,   // !
	0x00, 0x07, 0x00, 0x07, 0x00,   // "
	0x14, 0x7f, 0x14, 0x7f, 0x14,   // #
	0x24, 0x2a, 0x7f, 0x2a, 0x12,   // $
	0x23, 0x13, 0x08, 0x64, 0x62,   // %
	0x36, 0x49, 0x55, 0x22, 0x50,   // &
	0x00, 0x05, 0x03, 0x00, 0x00,   // '
	0x00, 0x1c, 0x22, 0x41, 0x00,   // (
	0x00, 0x41, 0x22, 0x1c, 0x00,   // )
	0x14, 0x08, 0x3E, 0x08, 0x14,   // *
	0x08, 0x08, 0x3E, 0x08, 0x08,   // +
	0x00, 0x00, 0xA0, 0x60, 0x00,   // ,
	0x08, 0x08, 0x08, 0x08, 0x08,   // -
	0x00, 0x60, 0x60, 0x00, 0x00,   // .
	0x20, 0x10, 0x08, 0x04, 0x02,   // /
	
	0x3E, 0x51, 0x49, 0x45, 0x3E,   // 0
	0x00, 0x42, 0x7F, 0x40, 0x00,   // 1
	0x42, 0x61, 0x51, 0x49, 0x46,   // 2
	0x21, 0x41, 0x45, 0x4B, 0x31,   // 3
	0x18, 0x14, 0x12, 0x7F, 0x10,   // 4
	0x27, 0x45, 0x45, 0x45, 0x39,   // 5
	0x3C, 0x4A, 0x49, 0x49, 0x30,   // 6
	0x01, 0x71, 0x09, 0x05, 0x03,   // 7
	0x36, 0x49, 0x49, 0x49, 0x36,   // 8
	0x06, 0x49, 0x49, 0x29, 0x1E,   // 9
	
	0x00, 0x36, 0x36, 0x00, 0x00,   // :
	0x00, 0x56, 0x36, 0x00, 0x00,   // ;
	0x08, 0x14, 0x22, 0x41, 0x00,   // <
	0x14, 0x14, 0x14, 0x14, 0x14,   // =
	0x00, 0x41, 0x22, 0x14, 0x08,   // >
	0x02, 0x01, 0x51, 0x09, 0x06,   // ?
	0x32, 0x49, 0x59, 0x51, 0x3E,   // @
	
	0x7C, 0x12, 0x11, 0x12, 0x7C,   // A
	0x7F, 0x49, 0x49, 0x49, 0x36,   // B
	0x3E, 0x41, 0x41, 0x41, 0x22,   // C
	0x7F, 0x41, 0x41, 0x22, 0x1C,   // D
	0x7F, 0x49, 0x49, 0x49, 0x41,   // E
	0x7F, 0x09, 0x09, 0x09, 0x01,   // F
	0x3E, 0x41, 0x49, 0x49, 0x7A,   // G
	0x7F, 0x08, 0x08, 0x08, 0x7F,   // H
	0x00, 0x41, 0x7F, 0x41, 0x00,   // I
	0x20, 0x40, 0x41, 0x3F, 0x01,   // J
	0x7F, 0x08, 0x14, 0x22, 0x41,   // K
	0x7F, 0x40, 0x40, 0x40, 0x40,   // L
	0x7F, 0x02, 0x0C, 0x02, 0x7F,   // M
	0x7F, 0x04, 0x08, 0x10, 0x7F,   // N
	0x3E, 0x41, 0x41, 0x41, 0x3E,   // O
	0x7F, 0x09, 0x09, 0x09, 0x06,   // P
	0x3E, 0x41, 0x51, 0x21, 0x5E,   // Q
	0x7F, 0x09, 0x19, 0x29, 0x46,   // R
	0x46, 0x49, 0x49, 0x49, 0x31,   // S
	0x01, 0x01, 0x7F, 0x01, 0x01,   // T
	0x3F, 0x40, 0x40, 0x40, 0x3F,   // U
	0x1F, 0x20, 0x40, 0x20, 0x1F,   // V
	0x3F, 0x40, 0x38, 0x40, 0x3F,   // W
	0x63, 0x14, 0x08, 0x14, 0x63,   // X
	0x07, 0x08, 0x70, 0x08, 0x07,   // Y
	0x61, 0x51, 0x49, 0x45, 0x43,   // Z
	
	0x00, 0x7F, 0x41, 0x41, 0x00,   // [
	0x55, 0xAA, 0x55, 0xAA, 0x55,   // Backslash (Checker pattern)
	0x00, 0x41, 0x41, 0x7F, 0x00,   // ]
	0x04, 0x02, 0x01, 0x02, 0x04,   // ^
	0x40, 0x40, 0x40, 0x40, 0x40,   // _
	0x00, 0x03, 0x05, 0x00, 0x00,   // `
	
	0x20, 0x54, 0x54, 0x54, 0x78,   // a
	0x7F, 0x48, 0x44, 0x44, 0x38,   // b
	0x38, 0x44, 0x44, 0x44, 0x20,   // c
	0x38, 0x44, 0x44, 0x48, 0x7F,   // d
	0x38, 0x54, 0x54, 0x54, 0x18,   // e
	0x08, 0x7E, 0x09, 0x01, 0x02,   // f
	0x18, 0xA4, 0xA4, 0xA4, 0x7C,   // g
	0x7F, 0x08, 0x04, 0x04, 0x78,   // h
	0x00, 0x44, 0x7D, 0x40, 0x00,   // i
	0x40, 0x80, 0x84, 0x7D, 0x00,   // j
	0x7F, 0x10, 0x28, 0x44, 0x00,   // k
	0x00, 0x41, 0x7F, 0x40, 0x00,   // l
	0x7C, 0x04, 0x18, 0x04, 0x78,   // m
	0x7C, 0x08, 0x04, 0x04, 0x78,   // n
	0x38, 0x44, 0x44, 0x44, 0x38,   // o
	0xFC, 0x24, 0x24, 0x24, 0x18,   // p
	0x18, 0x24, 0x24, 0x18, 0xFC,   // q
	0x7C, 0x08, 0x04, 0x04, 0x08,   // r
	0x48, 0x54, 0x54, 0x54, 0x20,   // s
	0x04, 0x3F, 0x44, 0x40, 0x20,   // t
	0x3C, 0x40, 0x40, 0x20, 0x7C,   // u
	0x1C, 0x20, 0x40, 0x20, 0x1C,   // v
	0x3C, 0x40, 0x30, 0x40, 0x3C,   // w
	0x44, 0x28, 0x10, 0x28, 0x44,   // x
	0x1C, 0xA0, 0xA0, 0xA0, 0x7C,   // y
	0x44, 0x64, 0x54, 0x4C, 0x44,   // z
	
	0x00, 0x10, 0x7C, 0x82, 0x00,   // {
		0x00, 0x00, 0xFF, 0x00, 0x00,   // |
	0x00, 0x82, 0x7C, 0x10, 0x00,   // }
	0x00, 0x06, 0x09, 0x09, 0x06    // ~ (Degrees)
};


// Initialize the OLED 
void OLED_Init(void) {
	i2c_init();
	oledSendCommand(0xAE); // display off
	oledSendCommand(0xD5); oledSendCommand(0x80);
	oledSendCommand(0xA8); oledSendCommand(0x3F);
	oledSendCommand(0xD3); oledSendCommand(0x00);
	oledSendCommand(0x40);
	oledSendCommand(0x8D); oledSendCommand(0x14);
	oledSendCommand(0x20); oledSendCommand(0x00);
	oledSendCommand(0xA1);
	oledSendCommand(0xC8);
	oledSendCommand(0xDA); oledSendCommand(0x12);
	oledSendCommand(0x81); oledSendCommand(0xCF);
	oledSendCommand(0xD9); oledSendCommand(0xF1);
	oledSendCommand(0xDB); oledSendCommand(0x40);
	oledSendCommand(0xA4);
	oledSendCommand(0xA6);
	oledSendCommand(0xAF); // display on
}

// Clear entire display
void OLED_Clear(void) {
	// column addr
	oledSendCommand(0x21); oledSendCommand(0); oledSendCommand(127);
	// page addr
	oledSendCommand(0x22); oledSendCommand(0); oledSendCommand(7);

	oledSendStart(SSD1306_ADDRESS);
	i2c_write(SSD1306_DATA_CONTINUE);
	for (uint16_t i = 0; i < 1024; i++)
	i2c_write(0x00);
	oledSendStop();
}

// Position cursor (line = 0..7, col = 0..127)
void OLED_SetCursor(uint8_t line, uint8_t col) {
	oledSendCommand(0x21);
	oledSendCommand(col);
	oledSendCommand(127);
	oledSendCommand(0x22);
	oledSendCommand(line);
	oledSendCommand(7);
	oledSendStart(SSD1306_ADDRESS);
	i2c_write(SSD1306_DATA_CONTINUE);
}

void OLED_DisplayChar(uint8_t ch) {
	if (ch < 0x20 || ch > 0x7F) ch = '?';
	const uint8_t *glyph = OledFontTable[ch - 0x20];
	for (uint8_t i = 0; i < 5; i++)
	oledSendData(glyph[i]);
	oledSendData(0x00); // inter-char space
}

// Display a null-terminated string
void OLED_DisplayString(const char *s) {
	while (*s) {
		OLED_DisplayChar((uint8_t)*s++);
	}
}

// float with 2 decimals
void OLED_DisplayFloatNumber(double num) {
	char buf[10];
	dtostrf(num, 6, 2, buf);
	OLED_DisplayString(buf);
}

// Complementary filter 
#define GYRO_SENS 16.4f
#define DT        0.01f

int16_t accData[3], gyrData[3];
volatile float pitch, roll, yaw;

void ComplementaryFilter(void) {
	// integrate gyro
	pitch += (gyrData[0] / GYRO_SENS) * DT;
	roll  -= (gyrData[1] / GYRO_SENS) * DT;
	yaw   += (gyrData[2] / GYRO_SENS) * DT;

	int32_t mag = abs(accData[0]) + abs(accData[1]) + abs(accData[2]);
	if (mag > 8192 && mag < 32768) {
		float pAcc = atan2f(accData[1], accData[2]) * 180.0f / M_PI;
		float rAcc = atan2f(accData[0], accData[2]) * 180.0f / M_PI;
		pitch = pitch * 0.98f + pAcc * 0.02f;
		roll  = roll  * 0.98f + rAcc  * 0.02f;
	}
}

int main(void) {
	i2c_init();
	bmi160_init();
	OLED_Init();

	_delay_ms(200);
	OLED_Clear();
	OLED_SetCursor(0, 0);
	OLED_DisplayString("IMU + OLED Demo");

	while (1) {
		// read IMU
		bmi160_read_accel(&accData[0], &accData[1], &accData[2]);
		bmi160_read_gyro (&gyrData[0], &gyrData[1], &gyrData[2]);

		// filter
		ComplementaryFilter();

		// render
		OLED_Clear();

		OLED_SetCursor(0, 0);
		OLED_DisplayString("P: ");
		OLED_DisplayFloatNumber(pitch);

		OLED_SetCursor(1, 0);
		OLED_DisplayString("R: ");
		OLED_DisplayFloatNumber(roll);

		OLED_SetCursor(2, 0);
		OLED_DisplayString("Y: ");
		OLED_DisplayFloatNumber(yaw);

		_delay_ms(10);
	}
	return 0;
}
